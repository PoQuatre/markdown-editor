{"mappings":"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","sources":["node_modules/@codemirror/stream-parser/dist/index.js"],"sourcesContent":["import { NodeType, NodeSet, Parser, NodeProp, Tree } from '@lezer/common';\nimport { tags, styleTags } from '@codemirror/highlight';\nimport { Language, defineLanguageFacet, indentService, syntaxTree, ParseContext, getIndentUnit, languageDataProp } from '@codemirror/language';\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, docID(data), [indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new NodeProp({ perNode: true });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for (let i = 0; i < tree.children.length; i++) {\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while (this.ranges[this.rangeIndex].to < this.parsedPos)\n            this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* MaxLineLength */)\n                    break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [NodeType.none];\nconst nodeSet = /*@__PURE__*/new NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra) {\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = (extra[part] || tags[part]);\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexport { StreamLanguage, StringStream };\n"],"names":["$8TSCy","parcelRequire","$2d4a95728091a359$var$countCol","string","end","tabSize","startIndex","arguments","length","startValue","search","n","i","charCodeAt","$2d4a95728091a359$export$72a09304cc8c1940","indentUnit","this","pos","start","lastColumnPos","lastColumnValue","key","value","charAt","undefined","match","ch","RegExp","test","eat","found","indexOf","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","match1","slice","index","$2d4a95728091a359$var$defaultCopyState","state","newState","prop","val","Array","$2d4a95728091a359$export$5ee3cc23916207d8","Language","parser","self","spec","data","$5gnvt","defineLanguageFacet","languageData","p","token","blankLine","startState","copyState","indent","tokenTable","$2d4a95728091a359$var$noTokens","impl","Parser","input","fragments","ranges","$2d4a95728091a359$var$Parse","$33Vcp","type","NodeType","define","id","$2d4a95728091a359$var$typeArray","name","props","languageDataProp","add","push","$2d4a95728091a359$var$docID","indentService","of","cx","_this","getIndent","assertThisInitialized","streamParser","stateAfter","NodeProp","perNode","$2d4a95728091a359$var$TokenTable","$2d4a95728091a359$var$defaultTokenTable","tree","syntaxTree","at","resolve","topNode","parent","statePos","$2d4a95728091a359$var$findState","from","unit","line","doc","lineAt","Math","min","to","stream","text","$2d4a95728091a359$var$readToken","exec","get","lang","off","startPos","before","children","child","positions","Tree","$2d4a95728091a359$var$cutTree","inside","inner","concat","stoppedAt","chunks","chunkPos","chunk","chunkReused","rangeIndex","context","ParseContext","ref","editorState","_iteratorNormalCompletion1","_didIteratorError1","_iteratorError1","_step1","_iterator1","Symbol","iterator","next","done","f","openStart","openEnd","offset","err","return","getIndentUnit","empty","$2d4a95728091a359$var$findStartInFragments","parsedPos","chunkStart","viewport","skipUntilInView","moveRangeIndex","parseEnd","parseLine","finishChunk","finish","lineChunks","eol","lineAfter","rangeEnd","rangeStart","after","side","offPos","size","skipGapsTo","len0","nextLine","emitToken","build","buffer","nodeSet","$2d4a95728091a359$var$nodeSet","topID","maxBufferLength","reused","balance","result","Error","Object","create","none","NodeSet","$2d4a95728091a359$var$warned","$2d4a95728091a359$var$defaultTable","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_value","slicedToArray","legacyName","$2d4a95728091a359$var$createTokenType","extra","table","assign","tag","$2d4a95728091a359$var$warnForPart","part","msg","console","warn","tagStr","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","split","$hneOf","tags","replace","styleTags","defineProperty"],"version":3,"file":"dist.89a138fe.js.map"}
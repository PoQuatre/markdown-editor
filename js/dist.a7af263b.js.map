{"mappings":"oVAAA,IAAAA,EAAAC,EAAA,mCAMA,SAASC,EAASC,EAAQC,EAAKC,EAASC,EAAa,EAAGC,EAAa,GACtD,MAAPH,IAEW,IADXA,EAAMD,EAAOK,OAAM,kBAEfJ,EAAMD,EAAOM,QAErB,IAAIC,EAAIH,EACR,IAAK,IAAII,EAAIL,EAAYK,EAAIP,EAAKO,IACF,GAAxBR,EAAOS,WAAWD,GAClBD,GAAKL,EAAWK,EAAIL,EAEpBK,IAER,OAAOA,EAMX,MAAMG,EA8BFC,MAAQ,OAAOC,KAAKC,KAAOD,KAAKZ,OAAOM,OAIvCQ,MAAQ,OAAmB,GAAZF,KAAKC,IAKpBE,OAAS,OAAOH,KAAKZ,OAAOgB,OAAOJ,KAAKC,WAAQI,EAIhDC,OACI,GAAIN,KAAKC,IAAMD,KAAKZ,OAAOM,OACvB,OAAOM,KAAKZ,OAAOgB,OAAOJ,KAAKC,OAMvCM,IAAIC,GACA,IACIC,EADAC,EAAKV,KAAKZ,OAAOgB,OAAOJ,KAAKC,KAMjC,GAHIQ,EADgB,iBAATD,EACFE,GAAMF,EAENE,IAAOF,aAAiBG,OAASH,EAAMI,KAAKF,GAAMF,EAAME,IAC7DD,EAEA,QADET,KAAKC,IACAS,EAQfG,SAASL,GACL,IAAIM,EAAQd,KAAKC,IACjB,KAAOD,KAAKO,IAAIC,KAChB,OAAOR,KAAKC,IAAMa,EAMtBC,WACI,IAAID,EAAQd,KAAKC,IACjB,KAAO,aAAaW,KAAKZ,KAAKZ,OAAOgB,OAAOJ,KAAKC,SAC3CD,KAAKC,IACX,OAAOD,KAAKC,IAAMa,EAKtBE,YAAchB,KAAKC,IAAMD,KAAKZ,OAAOM,OAKrCuB,OAAOP,GACH,IAAIQ,EAAQlB,KAAKZ,OAAO+B,QAAQT,EAAIV,KAAKC,KACzC,GAAIiB,GAAQ,EAER,OADAlB,KAAKC,IAAMiB,GACJ,EAMfE,OAAOzB,GAAKK,KAAKC,KAAON,EAIxB0B,SAKI,OAJIrB,KAAKsB,cAAgBtB,KAAKc,QAC1Bd,KAAKuB,gBAAkBpC,EAASa,KAAKZ,OAAQY,KAAKc,MAAOd,KAAKV,QAASU,KAAKsB,cAAetB,KAAKuB,iBAChGvB,KAAKsB,cAAgBtB,KAAKc,OAEvBd,KAAKuB,gBAKhBC,cACI,OAAOrC,EAASa,KAAKZ,OAAQ,KAAMY,KAAKV,SAa5CkB,MAAMiB,EAASC,EAASC,GACpB,GAAsB,iBAAXF,EAAqB,CAC5B,IAAIG,EAASC,GAAQF,EAAkBE,EAAIC,cAAgBD,EAE3D,OAAID,EADS5B,KAAKZ,OAAO2C,OAAO/B,KAAKC,IAAKwB,EAAQ/B,UAC7BkC,EAAMH,KACP,IAAZC,IACA1B,KAAKC,KAAOwB,EAAQ/B,SACjB,GAGA,KAEV,CACD,IAAIc,EAAQR,KAAKZ,OAAO4C,MAAMhC,KAAKC,KAAKO,MAAMiB,GAC9C,OAAIjB,GAASA,EAAMyB,MAAQ,EAChB,MACPzB,IAAqB,IAAZkB,IACT1B,KAAKC,KAAOO,EAAM,GAAGd,QAClBc,IAMf0B,UAAY,OAAOlC,KAAKZ,OAAO4C,MAAMhC,KAAKc,MAAOd,KAAKC,KArJtDkC,YAIA/C,EAAQE,EAIR8C,GACIpC,KAAKZ,OAASA,EACdY,KAAKV,QAAUA,EACfU,KAAKoC,WAAaA,EAIlBpC,KAAKC,IAAM,EAIXD,KAAKc,MAAQ,EACbd,KAAKsB,cAAgB,EACrBtB,KAAKuB,gBAAkB,GA8I/B,SAASc,EAAiBC,GACtB,GAAoB,iBAATA,EACP,OAAOA,EACX,IAAIC,EAAW,GACf,IAAK,IAAIC,KAAQF,EAAO,CACpB,IAAIG,EAAMH,EAAME,GAChBD,EAASC,GAASC,aAAeC,MAAQD,EAAIT,QAAUS,EAE3D,OAAOF,EAMX,MAAMI,UAAuBC,EAAAC,SAezBC,cAAcC,GAAQ,OAAO,IAAIJ,EAAeI,GAChDC,UAAUC,EAAIhD,GACV,IAAIiD,EAAON,EAAAO,WAAWF,EAAGX,OAAQc,EAAKF,EAAKG,QAAQpD,GACnD,KAAOmD,GAAMA,EAAGE,MAAQtD,KAAKuD,SACzBH,EAAKA,EAAGI,OACZ,IAAKJ,EACD,OAAO,KACX,IAAoDK,EAAUnB,EAA1DxB,EAAQ4C,EAAU1D,KAAMkD,EAAM,EAAGE,EAAGO,KAAM1D,GAS9C,GARIa,GACAwB,EAAQxB,EAAMwB,MACdmB,EAAW3C,EAAMb,IAAM,IAGvBqC,EAAQtC,KAAK4D,aAAaC,WAAWZ,EAAGa,MACxCL,EAAW,GAEXxD,EAAMwD,EAAW,IACjB,OAAO,KACX,KAAOA,EAAWxD,GAAK,CACnB,IAAI8D,EAAOd,EAAGX,MAAM0B,IAAIC,OAAOR,GAAWpE,EAAM6E,KAAKC,IAAIlE,EAAK8D,EAAKK,IACnE,GAAIL,EAAKrE,OAAQ,CACb,IAAI2E,EAAS,IAAIvE,EAAaiE,EAAKO,KAAMrB,EAAGX,MAAMhD,QAAS2D,EAAGa,MAC9D,KAAOO,EAAOpE,IAAMZ,EAAM0E,EAAKJ,MAC3BY,EAAUvE,KAAK4D,aAAaY,MAAOH,EAAQ/B,QAG/CtC,KAAK4D,aAAaa,UAAUnC,EAAOW,EAAGa,MAE1C,GAAIzE,GAAOY,EACP,MACJwD,EAAWM,EAAKK,GAAK,EAEzB,IA7PRE,KA6PcA,GAASrB,EAAGgB,OAAOhE,GACzB,OAAOD,KAAK4D,aAAac,OAAOpC,EAAO,WAAWqC,KAAKL,GAAM,GAAIrB,GAEjE2B,oBAAkB,OAAO,EAjD7BzC,YAAY0C,GACR,IAC4BC,EADxBC,EAAOnC,EAAAoC,oBAAoBH,EAAOI,cAClCC,EA3BD,CACHV,OAFYzB,EA4BO8B,GA1BPL,MACZC,UAAW1B,EAAK0B,WAAc,SAC9BZ,WAAYd,EAAKc,YAAe,MAAM,GACtCsB,UAAWpC,EAAKoC,WAAa9C,EAC7BqC,OAAQ3B,EAAK2B,QAAW,KAAM,MAC9BO,aAAclC,EAAKkC,cAAgB,GACnCG,WAAYrC,EAAKqC,YAAcC,GARvC,IAAoBtC,EAkCZuC,MAAMP,EALK,IAAI,cAAc9F,EAAAsG,OACzBC,YAAYC,EAAOC,EAAWC,GAC1B,OAAO,IAAIC,EAAMd,EAAMW,EAAOC,EAAWC,KA+SzD,SAAeZ,GACX,IAAIzB,EAAOrE,EAAA4G,SAASC,OAAO,CAAEC,GAAIC,EAAUtG,OAAQuG,KAAM,WAAYC,MAAO,CAACtD,EAAAuD,iBAAiBC,KAAI,IAAMrB,OAExG,OADAiB,EAAUK,KAAK/C,GACRA,EA/SegD,CAAMvB,GAAO,CAACnC,EAAA2D,cAAcC,IAAG,CAACvD,EAAIhD,IAAQD,KAAKgD,UAAUC,EAAIhD,OACjF6E,EAAO9E,KACPA,KAAK4D,aAAesB,EACpBlF,KAAKyG,WAAa,IAAIxH,EAAAyH,SAAS,CAAEC,SAAS,IAC1C3G,KAAKoF,WAAaP,EAAOO,WAAa,IAAIwB,EAAW1B,EAAEE,YAAcyB,GAuC7E,SAASnD,EAAUoD,EAAM5D,EAAM6D,EAAKC,EAAUC,GAC1C,IAAI3E,EAAQyE,GAAOC,GAAYD,EAAM7D,EAAKxD,QAAUuH,GAAU/D,EAAKV,KAAKsE,EAAKL,YAC7E,GAAInE,EACA,MAAO,CAAEA,MAAOwE,EAAKlD,aAAauB,UAAU7C,GAAQrC,IAAK8G,EAAM7D,EAAKxD,QACxE,IAAK,IAAIE,EAAIsD,EAAKgE,SAASxH,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAChD,IAAIuH,EAAQjE,EAAKgE,SAAStH,GAAIK,EAAM8G,EAAM7D,EAAKkE,UAAUxH,GACrDsB,EAAQiG,aAAiBlI,EAAAoI,MAAQpH,EAAMgH,GAAUvD,EAAUoD,EAAMK,EAAOlH,EAAK+G,EAAUC,GAC3F,GAAI/F,EACA,OAAOA,EAEf,OAAO,KAEX,SAASoG,EAAQR,EAAM5D,EAAMS,EAAMS,EAAImD,GACnC,GAAIA,GAAU5D,GAAQ,GAAKS,GAAMlB,EAAKxD,OAClC,OAAOwD,EACNqE,GAAUrE,EAAKI,MAAQwD,EAAKvD,UAC7BgE,GAAS,GACb,IAAK,IAAI3H,EAAIsD,EAAKgE,SAASxH,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAChD,IAAuD4H,EAAnDvH,EAAMiD,EAAKkE,UAAUxH,GAAIuH,EAAQjE,EAAKgE,SAAStH,GACnD,GAAIK,EAAMmE,GAAM+C,aAAiBlI,EAAAoI,KAAM,CACnC,KAAMG,EAAQF,EAAQR,EAAMK,EAAOxD,EAAO1D,EAAKmE,EAAKnE,EAAKsH,IACrD,MACJ,OAAQA,EACF,IAAItI,EAAAoI,KAAKnE,EAAKI,KAAMJ,EAAKgE,SAASlF,MAAM,EAAGpC,GAAG6H,OAAOD,GAAQtE,EAAKkE,UAAUpF,MAAM,EAAGpC,EAAI,GAAIK,EAAMuH,EAAM9H,QAD9F8H,GAIzB,OAAO,KAWX,MAAM5B,EA4BF8B,UACI,IAAIC,EAAU/E,EAAAgF,aAAaC,MACvBC,EAA6B,MAAlB9H,KAAK+H,UAAoB/H,KAAKoE,GAAKF,KAAKC,IAAInE,KAAKoE,GAAIpE,KAAK+H,WACrE1I,EAAM6E,KAAKC,IAAI2D,EAAU9H,KAAKgI,WAAa,MAG/C,IAFIL,IACAtI,EAAM6E,KAAKC,IAAI9E,EAAKsI,EAAQM,SAAS7D,KAClCpE,KAAKkI,UAAY7I,GACpBW,KAAKmI,UAAUR,GAGnB,OAFI3H,KAAKgI,WAAahI,KAAKkI,WACvBlI,KAAKoI,cACLpI,KAAKkI,WAAaJ,EACX9H,KAAKqI,SACZV,GAAW3H,KAAKkI,WAAaP,EAAQM,SAAS7D,IAC9CuD,EAAQW,gBAAgBtI,KAAKkI,UAAWJ,GACjC9H,KAAKqI,UAET,KAEXE,OAAOtI,GACHD,KAAK+H,UAAY9H,EAErBuI,UAAUvI,GACN,IAAIwI,EAAQzI,KAAKyF,MAAMgD,MAAMxI,GAC7B,GAAKD,KAAKyF,MAAMiD,WAKE,MAATD,IACLA,EAAQ,QANgB,CACxB,IAAI1I,EAAM0I,EAAMtH,QAAQ,MACpBpB,GAAM,IACN0I,EAAQA,EAAMzG,MAAM,EAAGjC,IAK/B,OAAOE,EAAMwI,EAAM/I,QAAUM,KAAKoE,GAAKqE,EAAQA,EAAMzG,MAAM,EAAGhC,KAAKoE,GAAKnE,GAE5E0I,WACI,IAAIhF,EAAO3D,KAAKkI,UAAWnE,EAAO/D,KAAKwI,UAAU7E,GAAOtE,EAAMsE,EAAOI,EAAKrE,OAC1E,IAAK,IAAIuC,EAAQjC,KAAK4I,aAAc,CAChC,IAAIC,EAAW7I,KAAK2F,OAAO1D,GAAOmC,GAClC,GAAIyE,GAAYxJ,EACZ,MAGJ,GAFA0E,EAAOA,EAAK/B,MAAM,EAAG6G,GAAYxJ,EAAM0E,EAAKrE,SAC5CuC,IACIA,GAASjC,KAAK2F,OAAOjG,OACrB,MACJ,IAAIoJ,EAAa9I,KAAK2F,OAAO1D,GAAO0B,KAChCoF,EAAQ/I,KAAKwI,UAAUM,GAC3B/E,GAAQgF,EACR1J,EAAMyJ,EAAaC,EAAMrJ,OAE7B,MAAO,CAnXfqE,KAmXiBA,EAnXjB1E,IAmXuBA,GAEnB2J,WAAW/I,EAAKgJ,EAAQC,GACpB,OAAS,CACL,IAAI7J,EAAMW,KAAK2F,OAAO3F,KAAK4I,YAAYxE,GAAI+E,EAASlJ,EAAMgJ,EAC1D,GAAIC,EAAO,EAAI7J,EAAM8J,EAAS9J,GAAO8J,EACjC,MAEJF,GADYjJ,KAAK2F,SAAS3F,KAAK4I,YAAYjF,KACzBtE,EAEtB,OAAO4J,EAEXG,iBACI,KAAOpJ,KAAK2F,OAAO3F,KAAK4I,YAAYxE,GAAKpE,KAAKkI,WAC1ClI,KAAK4I,aAEbS,UAAUtD,EAAIpC,EAAMS,EAAIkF,EAAML,GAC1B,GAAIjJ,KAAK2F,OAAOjG,OAAS,EAAG,CAExBiE,GADAsF,EAASjJ,KAAKgJ,WAAWrF,EAAMsF,EAAQ,GAEvC,IAAIM,EAAOvJ,KAAKyI,MAAM/I,OAEtB0E,GADA6E,EAASjJ,KAAKgJ,WAAW5E,EAAI6E,GAAQ,GAErCK,GAAQtJ,KAAKyI,MAAM/I,OAAS6J,EAGhC,OADAvJ,KAAKyI,MAAMpC,KAAKN,EAAIpC,EAAMS,EAAIkF,GACvBL,EAEXd,UAAUR,GACN,IAhZR5D,KAgZcA,EAhZd1E,IAgZoBA,GAAQW,KAAK2I,WAAYM,EAAS,GAhZtDrF,aAgZ2DA,GAAiB5D,KAAK8G,KACrEzC,EAAS,IAAIvE,EAAaiE,EAAM4D,EAAUA,EAAQrF,MAAMhD,QAAU,EAAGqI,EAAU/E,EAAA4G,cAAc7B,EAAQrF,OAAS,GAClH,GAAI+B,EAAOtE,MACP6D,EAAaa,UAAUzE,KAAKsC,MAAO+B,EAAOjC,iBAG1C,MAAQiC,EAAOtE,OAAO,CAClB,IAAIyE,EAAQD,EAAUX,EAAaY,MAAOH,EAAQrE,KAAKsC,OAGvD,GAFIkC,IACAyE,EAASjJ,KAAKqJ,UAAUrJ,KAAK8G,KAAK1B,WAAW/B,QAAQmB,GAAQxE,KAAKkI,UAAY7D,EAAOvD,MAAOd,KAAKkI,UAAY7D,EAAOpE,IAAK,EAAGgJ,IAC5H5E,EAAOvD,MAAQ,IACf,MAGZd,KAAKkI,UAAY7I,EACjBW,KAAKoJ,iBACDpJ,KAAKkI,UAAYlI,KAAKoE,IACtBpE,KAAKkI,YAEbE,cACI,IAAIlF,EAAOjE,EAAAoI,KAAKoC,MAAM,CAClBC,OAAQ1J,KAAKyI,MACb3H,MAAOd,KAAKgI,WACZtI,OAAQM,KAAKkI,UAAYlI,KAAKgI,WAva1C2B,QAwaYC,EACAC,MAAO,EACPC,gBAAiB,KACjBC,OAAQ/J,KAAKgK,cAEjB9G,EAAO,IAAIjE,EAAAoI,KAAKnE,EAAKI,KAAMJ,EAAKgE,SAAUhE,EAAKkE,UAAWlE,EAAKxD,OAAQ,CAAC,CAACM,KAAK8G,KAAKL,WAAYzG,KAAK8G,KAAKlD,aAAauB,UAAUnF,KAAKsC,UACrItC,KAAKiK,OAAO5D,KAAKnD,GACjBlD,KAAKkK,SAAS7D,KAAKrG,KAAKgI,WAAahI,KAAK2F,OAAO,GAAGhC,MACpD3D,KAAKyI,MAAQ,GACbzI,KAAKgK,iBAAc3J,EACnBL,KAAKgI,WAAahI,KAAKkI,UAE3BG,SACI,OAAO,IAAIpJ,EAAAoI,KAAKrH,KAAK8G,KAAKvD,QAASvD,KAAKiK,OAAQjK,KAAKkK,SAAUlK,KAAKkI,UAAYlI,KAAK2F,OAAO,GAAGhC,MAAMwG,UA7IzGhI,YAAY2E,EAAMrB,EAAOC,EAAWC,GAChC3F,KAAK8G,KAAOA,EACZ9G,KAAKyF,MAAQA,EACbzF,KAAK0F,UAAYA,EACjB1F,KAAK2F,OAASA,EACd3F,KAAK+H,UAAY,KACjB/H,KAAKiK,OAAS,GACdjK,KAAKkK,SAAW,GAChBlK,KAAKyI,MAAQ,GACbzI,KAAKgK,iBAAc3J,EACnBL,KAAK4I,WAAa,EAClB5I,KAAKoE,GAAKuB,EAAOA,EAAOjG,OAAS,GAAG0E,GACpC,IAAIuD,EAAU/E,EAAAgF,aAAaC,MAAOlE,EAAOgC,EAAO,GAAGhC,MApT3DrB,MAqTcA,EArTdY,KAqTqBA,GAvBrB,SAA8B4D,EAAMpB,EAAWsB,EAAUoD,GACrD,IAAK,IAAIC,KAAK3E,EAAW,CACrB,IACsGxC,EADlGS,EAAO0G,EAAE1G,MAAQ0G,EAAEC,UAAY,GAAK,GAAIlG,EAAKiG,EAAEjG,IAAMiG,EAAEE,QAAU,GAAK,GACtErJ,EAAQyC,GAAQqD,GAAY5C,EAAK4C,GAAYtD,EAAUoD,EAAMuD,EAAEnH,KAAM,EAAImH,EAAEpB,OAAQjC,EAAU5C,GACjG,GAAIlD,IAAUgC,EAAOoE,EAAQR,EAAMuD,EAAEnH,KAAM8D,EAAWqD,EAAEpB,OAAQ/H,EAAMjB,IAAMoK,EAAEpB,QAAQ,IAClF,MAAO,CAAE3G,MAAOpB,EAAMoB,MAnSlCY,KAmSyCA,GAErC,MAAO,CAAEZ,MAAOwE,EAAKlD,aAAaC,WAAWuG,EAAcxH,EAAA4G,cAAcY,GAAe,GAAIlH,KAAMjE,EAAAoI,KAAKmD,OAgB7EC,CAAqB3D,EAAMpB,EAAW/B,EAAMgE,MAAAA,OAAyC,EAASA,EAAQrF,OAC5HtC,KAAKsC,MAAQA,EACbtC,KAAKkI,UAAYlI,KAAKgI,WAAarE,EAAOT,EAAKxD,OAC/C,IAAK,IAAIE,EAAI,EAAGA,EAAIsD,EAAKgE,SAASxH,OAAQE,IACtCI,KAAKiK,OAAO5D,KAAKnD,EAAKgE,SAAStH,IAC/BI,KAAKkK,SAAS7D,KAAKnD,EAAKkE,UAAUxH,IAElC+H,GAAW3H,KAAKkI,UAAYP,EAAQM,SAAStE,KAAO,MACpD3D,KAAKsC,MAAQtC,KAAK8G,KAAKlD,aAAaC,WAAWjB,EAAA4G,cAAc7B,EAAQrF,QACrEqF,EAAQW,gBAAgBtI,KAAKkI,UAAWP,EAAQM,SAAStE,MACzD3D,KAAKkI,UAAYP,EAAQM,SAAStE,MAEtC3D,KAAKoJ,kBAuHb,SAAS7E,EAAUC,EAAOH,EAAQ/B,GAC9B+B,EAAOvD,MAAQuD,EAAOpE,IACtB,IAAK,IAAIL,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAI8K,EAASlG,EAAMH,EAAQ/B,GAC3B,GAAI+B,EAAOpE,IAAMoE,EAAOvD,MACpB,OAAO4J,EAEf,MAAM,IAAIC,MAAM,2CAEpB,MAAMtF,EAAwBuF,OAAOC,OAAO,MACtC7E,EAAY,CAAC/G,EAAA4G,SAASiF,MACtBlB,EAAuB,IAAI3K,EAAA8L,QAAQ/E,GACnCgF,EAAS,GACTC,EAA4BL,OAAOC,OAAO,MAChD,IAAK,IAAKK,EAAYjF,IAAS,CAC3B,CAAC,WAAY,gBACb,CAAC,aAAc,wBACf,CAAC,WAAY,kBACb,CAAC,MAAO,2BACR,CAAC,MAAO,YACR,CAAC,YAAa,gBACd,CAAC,OAAQ,YACT,CAAC,UAAW,yBACZ,CAAC,YAAa,YACd,CAAC,QAAS,WACV,CAAC,SAAU,WACX,CAAC,WAAY,iBAEbgF,EAAaC,GAA2BC,EAAgB9F,EAAUY,GACtE,MAAMW,EAKFvD,QAAQ+H,GACJ,OAAQA,EAAUpL,KAAKqL,MAAMD,KAASpL,KAAKqL,MAAMD,GAAOD,EAAgBnL,KAAKsL,MAAOF,IAAtE,EALlBjJ,YAAYmJ,GACRtL,KAAKsL,MAAQA,EACbtL,KAAKqL,MAAQT,OAAOW,OAAOX,OAAOC,OAAO,MAAOI,IAMxD,MAAMpE,EAAiC,IAAID,EAAWvB,GACtD,SAASmG,EAAYC,EAAMC,GACnBV,EAAO7J,QAAQsK,IAAQ,IAE3BT,EAAO3E,KAAKoF,GACZE,QAAQC,KAAKF,IAEjB,SAASP,EAAgBG,EAAOO,GAC5B,IAAIT,EAAM,KACV,IAAK,IAAIK,KAAQI,EAAOC,MAAM,KAAM,CAChC,IAAIC,EAAST,EAAMG,IAASO,EAAAC,KAAKR,GAC5BM,EAGoB,mBAATA,EACPX,EAGDA,EAAMW,EAAMX,GAFZI,EAAYC,EAAM,YAAYA,0BAK9BL,EACAI,EAAYC,EAAM,OAAOA,sBAEzBL,EAAMW,EAZVP,EAAYC,EAAM,4BAA4BA,KAetD,IAAKL,EACD,OAAO,EACX,IAAIc,EAAOL,EAAOM,QAAO,KAAO,KAAM7I,EAAOrE,EAAA4G,SAASC,OAAO,CACzDC,GAAIC,EAAUtG,OA5ftBuG,KA6fQiG,EACAhG,MAAO,CAAC8F,EAAAI,UAAU,CAAEF,CAACA,GAAOd,OAGhC,OADApF,EAAUK,KAAK/C,GACRA,EAAKyC","sources":["node_modules/@codemirror/stream-parser/dist/index.js"],"sourcesContent":["import { NodeType, NodeSet, Parser, NodeProp, Tree } from '@lezer/common';\nimport { tags, styleTags } from '@codemirror/highlight';\nimport { Language, defineLanguageFacet, indentService, syntaxTree, ParseContext, getIndentUnit, languageDataProp } from '@codemirror/language';\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, docID(data), [indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new NodeProp({ perNode: true });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for (let i = 0; i < tree.children.length; i++) {\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while (this.ranges[this.rangeIndex].to < this.parsedPos)\n            this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* MaxLineLength */)\n                    break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [NodeType.none];\nconst nodeSet = /*@__PURE__*/new NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra) {\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = (extra[part] || tags[part]);\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexport { StreamLanguage, StringStream };\n"],"names":["$eolFT","parcelRequire","$6c934a31e0fb2b8c$var$countCol","string","end","tabSize","startIndex","startValue","search","length","n","i","charCodeAt","$6c934a31e0fb2b8c$export$72a09304cc8c1940","eol","this","pos","sol","peek","charAt","undefined","next","eat","match","ok","ch","RegExp","test","eatWhile","start","eatSpace","skipToEnd","skipTo","found","indexOf","backUp","column","lastColumnPos","lastColumnValue","indentation","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","slice","index","current","constructor","indentUnit","$6c934a31e0fb2b8c$var$defaultCopyState","state","newState","prop","val","Array","$6c934a31e0fb2b8c$export$5ee3cc23916207d8","$j8ezH","Language","static","spec","getIndent","cx","tree","syntaxTree","at","resolve","type","topNode","parent","statePos","$6c934a31e0fb2b8c$var$findState","from","streamParser","startState","unit","line","doc","lineAt","Math","min","to","stream","text","$6c934a31e0fb2b8c$var$readToken","token","blankLine","indent","exec","allowsNesting","parser","self","data","defineLanguageFacet","languageData","p","copyState","tokenTable","$6c934a31e0fb2b8c$var$noTokens","super","Parser","createParse","input","fragments","ranges","$6c934a31e0fb2b8c$var$Parse","NodeType","define","id","$6c934a31e0fb2b8c$var$typeArray","name","props","languageDataProp","add","push","$6c934a31e0fb2b8c$var$docID","indentService","of","stateAfter","NodeProp","perNode","$6c934a31e0fb2b8c$var$TokenTable","$6c934a31e0fb2b8c$var$defaultTokenTable","lang","off","startPos","before","children","child","positions","Tree","$6c934a31e0fb2b8c$var$cutTree","inside","inner","concat","advance","context","ParseContext","get","parseEnd","stoppedAt","chunkStart","viewport","parsedPos","parseLine","finishChunk","finish","skipUntilInView","stopAt","lineAfter","chunk","lineChunks","nextLine","rangeIndex","rangeEnd","rangeStart","after","skipGapsTo","offset","side","offPos","moveRangeIndex","emitToken","size","len0","getIndentUnit","build","buffer","nodeSet","$6c934a31e0fb2b8c$var$nodeSet","topID","maxBufferLength","reused","chunkReused","chunks","chunkPos","balance","editorState","f","openStart","openEnd","empty","$6c934a31e0fb2b8c$var$findStartInFragments","result","Error","Object","create","none","NodeSet","$6c934a31e0fb2b8c$var$warned","$6c934a31e0fb2b8c$var$defaultTable","legacyName","$6c934a31e0fb2b8c$var$createTokenType","tag","table","extra","assign","$6c934a31e0fb2b8c$var$warnForPart","part","msg","console","warn","tagStr","split","value","$hspI2","tags","name1","replace","styleTags"],"version":3,"file":"dist.a7af263b.js.map"}
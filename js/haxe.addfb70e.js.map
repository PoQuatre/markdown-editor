{"mappings":"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","sources":["node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"names":["$6ce25c00d54146f1$var$kw","type","style","$6ce25c00d54146f1$var$content","$6ce25c00d54146f1$var$A","$6ce25c00d54146f1$var$B","$6ce25c00d54146f1$var$C","$6ce25c00d54146f1$var$operator","$6ce25c00d54146f1$var$atom","$6ce25c00d54146f1$var$attribute","$6ce25c00d54146f1$var$type","$6ce25c00d54146f1$var$keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","$6ce25c00d54146f1$var$isOperatorChar","$6ce25c00d54146f1$var$chain","stream","state","f","tokenize","$6ce25c00d54146f1$var$toUnescaped","end","next","escaped","$6ce25c00d54146f1$var$ret","tp","cont","$6ce25c00d54146f1$var$haxeTokenBase","ch","quote","test","eat","eatWhile","match","reAllowed","$6ce25c00d54146f1$var$haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","maybeEnd","$6ce25c00d54146f1$var$atomicTypes","atom","number","variable","string","regexp","$6ce25c00d54146f1$var$HaxeLexical","indented","column","align","prev","info","this","$6ce25c00d54146f1$var$inScope","varname","v","localVars","name","$6ce25c00d54146f1$var$imported","typename","charAt","len","importedtypes","length","i","$6ce25c00d54146f1$var$registerimport","importname","$6ce25c00d54146f1$var$cx","t","marked","cc","$6ce25c00d54146f1$var$pass","arguments","push","$6ce25c00d54146f1$var$cont","apply","$6ce25c00d54146f1$var$inList","list","$6ce25c00d54146f1$var$register","context","globalVars","$6ce25c00d54146f1$var$defaultVars","$6ce25c00d54146f1$var$pushcontext","vars","$6ce25c00d54146f1$var$popcontext","$6ce25c00d54146f1$var$pushlex","result","lexical","lex","$6ce25c00d54146f1$var$poplex","$6ce25c00d54146f1$var$expect","wanted","$6ce25c00d54146f1$var$statement","$6ce25c00d54146f1$var$metadef","$6ce25c00d54146f1$var$vardef1","$6ce25c00d54146f1$var$expression","$6ce25c00d54146f1$var$block","$6ce25c00d54146f1$var$maybeattribute","$6ce25c00d54146f1$var$functiondef","$6ce25c00d54146f1$var$forspec1","$6ce25c00d54146f1$var$maybelabel","$6ce25c00d54146f1$var$funarg","$6ce25c00d54146f1$var$importdef","$6ce25c00d54146f1$var$typedef","hasOwnProperty","$6ce25c00d54146f1$var$maybeoperator","$6ce25c00d54146f1$var$maybeexpression","$6ce25c00d54146f1$var$commasep","$6ce25c00d54146f1$var$objprop","value","$6ce25c00d54146f1$var$property","$6ce25c00d54146f1$var$metaargs","what","proceed","$6ce25c00d54146f1$var$typeuse","$6ce25c00d54146f1$var$vardef2","$6ce25c00d54146f1$var$forin","_type","$6ce25c00d54146f1$var$typestring","$6ce25c00d54146f1$var$typeprop","$6ce25c00d54146f1$export$2e90d0ffbee70fc6","startState","indentUnit","token","sol","indentation","eatSpace","content","pop","$6ce25c00d54146f1$var$parseHaxe","indent","textAfter","cx","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","block","open","close","$6ce25c00d54146f1$export$ecfeb731a3c826cd","define","inString","peek","skipTo"],"version":3,"file":"haxe.addfb70e.js.map"}